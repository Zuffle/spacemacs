#+BEGIN_SRC emacs-lisp :results silent :tangle yes
  (defun el ()
    (insert "#+BEGIN_SRC emacs-lisp :results silent\n\n#+END_SRC")
    (previous-line 1)
    (insert "  "))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent :tangle yes
  (require 'eww)

  (defun call-fto-servlet (servlet-name)
    (let ((temp-buffer
           (url-retrieve-synchronously
            (format "http://firstthreeodds.org/%s" servlet-name) t t))
          headers
          content)
      (with-current-buffer temp-buffer
        (unwind-protect
            (setq headers (eww-parse-headers)
                  content (buffer-substring (point) (point-max)))))
      (kill-buffer temp-buffer)
      content))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent :tangle yes
  (require 'org)

  (defun get-tla-as-string (&optional tla-as-symbol) 
    (downcase (if tla-as-symbol
                  (symbol-name tla-as-symbol)
                (org-entry-get (point) "ITEM"))))

  (defun get-hint (&optional tla-as-symbol)
    (call-fto-servlet
     (format "mebewiyo/book/hint/%s"
             (get-tla-as-string tla-as-symbol))))

  (defun get-answer (key-as-number &optional tla-as-symbol)
    (call-fto-servlet
     (format "mebewiyo/book/answer/%s/%d"
             (get-tla-as-string tla-as-symbol) key-as-number)))
#+END_SRC

* Test Old Hint
  Supplying the optional parameter:
#+BEGIN_SRC emacs-lisp
  (get-hint 'CRC)
#+END_SRC

#+RESULTS:
#+begin_example
  ,#+ATTR_HTML: :alt desert image :title What is this doing here?!
  [[file:img/desert.jpg]]
  This is the first of many exercises/problems/puzzles to come, always signified
  by this type of yellow-background box. In every exercise box there will be a
  text input box leading to hints and answers. (Metahint: Focus the cursor in
  the input box and press Enter.)

  Several questions have been posed already. Identify and answer them.
:HINT:
  - Hint :: Some of the questions are implied, rather than explicitly stated.
            For example: What is the difference between /using/ a word and
            /mentioning/ it? Or another example: What does \ldquo{}TLA ISA\rdquo mean?
:END:
,#+BEGIN_SRC emacs-lisp :exports results :results html
  (insert-helpbox)
,#+END_SRC
#+end_example

* Test New Hints
  Getting the TLA identifier from the enclosing org-entry ITEM:
** OQP
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

** USV
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

** USV
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

** UOX
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

** OIO
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

** UIJ
#+BEGIN_SRC emacs-lisp
  (get-hint)
#+END_SRC

* Getting ABC EPP Answers

  For the keys, taking inspiration from USV, the code below prefixes with a
  string of 4 consecutive digits your I-Number with any leading digits
  preserved. That makes it a 13-digit string, which can be rotated right any
  number of times from 0 to 12, giving a different string each time.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun rot-n (str n)
    (setq n (- (mod n (length str))))
    (concat (substring str n) (substring str 0 n)))

  (defun abc-epp-key (prefix i-number n)
    (rot-n (format "%s%09d" prefix i-number) n))

  (defun oqp-key (i-number)
    (abc-epp-key "1234" i-number 0))

  (defun usv-key (i-number)
    (abc-epp-key "1234" i-number 1))

  (defun uca-key (i-number)
    (abc-epp-key "1234" i-number 2))

  (defun ods-key (i-number)
    (abc-epp-key "1234" i-number 3))

  (defun ugx-key (i-number)
    (abc-epp-key "1234" i-number 4))

  (defun ogr-key (i-number)
    (abc-epp-key "1234" i-number 5))

  (defun uwm-key (i-number)
    (abc-epp-key "1234" i-number 6))

  (defun opz-key (i-number)
    (abc-epp-key "1234" i-number 7))

  (defun uox-key (i-number)
    (abc-epp-key "1234" i-number 8))

  (defun otx-key (i-number)
    (abc-epp-key "1234" i-number 9))

  (defun uot-key (i-number)
    (abc-epp-key "1234" i-number 10))

  (defun oim-key (i-number)
    (abc-epp-key "1234" i-number 11))

  (defun uin-key (i-number)
    (abc-epp-key "1234" i-number 12))

  (defun ojl-key (i-number)
    (abc-epp-key "2345" i-number 0))

  (defun ucg-key (i-number)
    (abc-epp-key "2345" i-number 1))

  (defun oio-key (i-number)
    (abc-epp-key "2345" i-number 2))

  (defun uij-key (i-number)
    (abc-epp-key "2345" i-number 3))

  (defun oqt-key (i-number)
    (abc-epp-key "2345" i-number 4))

  (defun utq-key (i-number)
    (abc-epp-key "2345" i-number 5))

  (defun oyu-key (i-number)
    (abc-epp-key "2345" i-number 6))

  (defun uoh-key (i-number)
    (abc-epp-key "2345" i-number 7))

  (defun ozd-key (i-number)
    (abc-epp-key "2345" i-number 8))

  (defun uzm-key (i-number)
    (abc-epp-key "2345" i-number 9))

  (defun ooy-key (i-number)
    (abc-epp-key "2345" i-number 10))

  (defun ufz-key (i-number)
    (abc-epp-key "2345" i-number 11))

  (defun okj-key (i-number)
    (abc-epp-key "2345" i-number 12))

  (defun uvh-key (i-number)
    (abc-epp-key "3456" i-number 0))

  (defun ojm-key (i-number)
    (abc-epp-key "3456" i-number 1))

  (defun ulq-key (i-number)
    (abc-epp-key "3456" i-number 2))

  (defun otd-key (i-number)
    (abc-epp-key "3456" i-number 3))

  (defun uju-key (i-number)
    (abc-epp-key "3456" i-number 4))

  (defun olh-key (i-number)
    (abc-epp-key "3456" i-number 5))

  (defun uwy-key (i-number)
    (abc-epp-key "3456" i-number 6))

  (defun obw-key (i-number)
    (abc-epp-key "3456" i-number 7))

  (defun usl-key (i-number)
    (abc-epp-key "3456" i-number 8))

  (defun oyp-key (i-number)
    (abc-epp-key "3456" i-number 9))

  (defun ubv-key (i-number)
    (abc-epp-key "3456" i-number 10))

  (defun okq-key (i-number)
    (abc-epp-key "3456" i-number 11))

  (defun ukf-key (i-number)
    (abc-epp-key "3456" i-number 12))

  (defun okl-key (i-number)
    (abc-epp-key "4567" i-number 0))

  (defun uez-key (i-number)
    (abc-epp-key "4567" i-number 1))

  (defun oyw-key (i-number)
    (abc-epp-key "4567" i-number 2))

  (defun uef-key (i-number)
    (abc-epp-key "4567" i-number 3))

  (defun oub-key (i-number)
    (abc-epp-key "4567" i-number 4))

  (defun uqy-key (i-number)
    (abc-epp-key "4567" i-number 5))
#+END_SRC

* Getting DEF Answers

  We need to preserve leading zeros in i-numbers, hence this special
  list-of-digits function. And rotate-list-n is analogous to rot-n for strings.

#+BEGIN_SRC emacs-lisp :results silent :tangle yes

  (defun list-of-digits (n)
    (let ((str (format (if (< n 1000000000) "%09d" "%018d") n)))
      (mapcar (lambda (ch) (- ch ?0)) str)))

  (defun rotate-list-n (lst n)
    (setq n (mod n (length lst)))
    (append (-take-last (- (length lst) n) lst) (-take n lst)))

  (defun shuffle-list-n (lst n)
    (loop repeat n
          do (setq lst (apply 'shufflel (take-apart lst)))
          finally return lst))

  (defun def-epp-key (i-number rotate-n shuffle-n)
    (let* ((prefix-digits (list 5 9 2 6 3 4 1 7 8))
           (prefix-digits-rotated (rotate-list-n prefix-digits rotate-n))
           (i-number-digits (list-of-digits i-number))
           (all-digits (append prefix-digits-rotated i-number-digits))
           (all-digits-shuffled (shuffle-list-n all-digits shuffle-n)))
      (string-to-number
       (apply 'format "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d" all-digits-shuffled))))

  (defun tbd-key (i-number)
    (def-epp-key i-number 1 0))

  (defun wdk-key (i-number)
    (def-epp-key i-number 1 1))

  (defun tdr-key (i-number)
    (def-epp-key i-number 1 2))

  (defun wdt-key (i-number)
    (def-epp-key i-number 1 3))

  (defun teh-key (i-number)
    (def-epp-key i-number 1 4))

  (defun wfc-key (i-number)
    (def-epp-key i-number 1 5))

  (defun tej-key (i-number)
    (def-epp-key i-number 1 6))

  (defun wfk-key (i-number)
    (def-epp-key i-number 1 7))

  (defun ter-key (i-number)
    (def-epp-key i-number 1 8))

  (defun wgp-key (i-number)
    (def-epp-key i-number 2 0))

  (defun teu-key (i-number)
    (def-epp-key i-number 2 1))

  (defun wgw-key (i-number)
    (def-epp-key i-number 2 2))

  (defun tfv-key (i-number)
    (def-epp-key i-number 2 3))

  (defun wjs-key (i-number)
    (def-epp-key i-number 2 4))

  (defun tge-key (i-number)
    (def-epp-key i-number 2 5))

  (defun wkc-key (i-number)
    (def-epp-key i-number 2 6))

  (defun thp-key (i-number)
    (def-epp-key i-number 2 7))

  (defun wkm-key (i-number)
    (def-epp-key i-number 2 8))

  (defun tiw-key (i-number)
    (def-epp-key i-number 3 0))

  (defun wnw-key (i-number)
    (def-epp-key i-number 3 1))

  (defun tkg-key (i-number)
    (def-epp-key i-number 3 2))

  (defun wov-key (i-number)
    (def-epp-key i-number 3 3))

  (defun tme-key (i-number)
    (def-epp-key i-number 3 4))

  (defun wqw-key (i-number)
    (def-epp-key i-number 3 5))

  (defun tmz-key (i-number)
    (def-epp-key i-number 3 6))

  (defun wra-key (i-number)
    (def-epp-key i-number 3 7))

  (defun tnl-key (i-number)
    (def-epp-key i-number 3 8))

  (defun wrd-key (i-number)
    (def-epp-key i-number 4 0))

  (defun tnq-key (i-number)
    (def-epp-key i-number 4 1))

  (defun wrp-key (i-number)
    (def-epp-key i-number 4 2))

  (defun toj-key (i-number)
    (def-epp-key i-number 4 3))

  (defun wru-key (i-number)
    (def-epp-key i-number 4 4))

  (defun tol-key (i-number)
    (def-epp-key i-number 4 5))

  (defun wzo-key (i-number)
    (def-epp-key i-number 4 6))

  (defun tou-key (i-number)
    (def-epp-key i-number 4 7))

  (defun wyh-key (i-number)
    (def-epp-key i-number 4 8))

  (defun tli-key (i-number)
    (def-epp-key i-number 5 0))

  (defun wpi-key (i-number)
    (def-epp-key i-number 5 1))

  (defun tsd-key (i-number)
    (def-epp-key i-number 5 2))

  (defun wtm-key (i-number)
    (def-epp-key i-number 5 3))

  (defun ttv-key (i-number)
    (def-epp-key i-number 5 4))

  (defun wuz-key (i-number)
    (def-epp-key i-number 5 5))

  (defun wzm-key (i-number)
    (def-epp-key i-number 5 6))

  (defun tuk-key (i-number)
    (def-epp-key i-number 5 7))

  (defun wvq-key (i-number)
    (def-epp-key i-number 5 8))

  (defun tuq-key (i-number)
    (def-epp-key i-number 6 0))

  (defun wvu-key (i-number)
    (def-epp-key i-number 6 1))

  (defun tuw-key (i-number)
    (def-epp-key i-number 6 2))

  (defun wwd-key (i-number)
    (def-epp-key i-number 6 3))

  (defun tvl-key (i-number)
    (def-epp-key i-number 6 4))

  (defun wwr-key (i-number)
    (def-epp-key i-number 6 5))

  (defun twn-key (i-number)
    (def-epp-key i-number 6 6))

  (defun wws-key (i-number)
    (def-epp-key i-number 6 7))

  (defun txg-key (i-number)
    (def-epp-key i-number 6 8))

  (defun wzg-key (i-number)
    (def-epp-key i-number 7 0))

  (defun tkh-key (i-number)
    (def-epp-key i-number 7 1))

  (defun wue-key (i-number)
    (def-epp-key i-number 7 2))
#+END_SRC

* For Your Consideration, Profit and Learning
** EBQ

  Here is a much better way that defines a function that returns the Cartesian
  product of /three/ sets, and that also allows the sets to be of different
  sizes:
#+BEGIN_SRC emacs-lisp :results silent
  (defun cartesian-product-3 (s1 s2 s3)
    (loop for i across s1
          append (loop for j across s2
                       append (loop for k across s3
                                    collect (list i j k)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw
  (cartesian-product-3 [a b c d] [1 2] [x y z w t])
#+END_SRC

  We can do better still. The problem is to figure out how best to generalize
  this to a Cartesian product of /n/ sets, again allowing for arbitrary sizes.

*** A 9-line solution
#+BEGIN_SRC emacs-lisp :results silent
  (defun mappend (fn &rest lsts)
    "Maps fn over elements in lsts and finally appends all resulting lists."
    (apply 'append (apply 'mapcar fn lsts)))

  (defun cartesian-product (&rest lists)
    (if (null lists)
        (list nil)
      (mappend (lambda (x)
                 (mapcar (lambda (lst) (cons x lst))
                         (apply 'cartesian-product (cdr lists))))
       (car lists))))
#+END_SRC

*** A 13-line solution

    This solution demonstrates the power of lisp in writing code that creates
    other code:

#+BEGIN_SRC emacs-lisp :results silent
  (defun make-nested-loops-to-iterate-over-n-lists (n num-lists)
    (if (= n num-lists)
        (apply 'list 'list items)
      (append (list 'loop 'for (get-current-item n) 'in (list 'nth n 'lists))
              (list (if (< n (- num-lists 1)) 'append 'collect))
              (list (make-nested-loops-to-iterate-over-n-lists (+ n 1) num-lists)))))

  (defun get-current-item (n)
    (let ((item (intern (format "i%d" n))))
      (setq items (append items (list item)))
      item))

  (defun cart-prod (&rest lists)
    (let ((items nil))
      (eval (make-nested-loops-to-iterate-over-n-lists 0 (length lists)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp :results raw 
  (cart-prod '(a b) '(1 2 3) '(w x y z))
#+END_SRC
